<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>reason的学习记录</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="reason的学习记录">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="reason的学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="reason">
<meta property="article:tag" content="三维点云 前端开发">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="reason的学习记录" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">reason的学习记录</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle"> </a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Day12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/05/Day12/" class="article-date">
  <time class="dt-published" datetime="2025-10-05T14:17:37.000Z" itemprop="datePublished">2025-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/05/Day12/">Day12</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/05/Day12/" data-id="cmgdsdu0n0000v0d1c0eb35rt" data-title="Day12" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Day11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/05/Day11/" class="article-date">
  <time class="dt-published" datetime="2025-10-05T12:42:20.000Z" itemprop="datePublished">2025-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/05/Day11/">GO语言教程Day11</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-运算符联系题"><a href="#1-运算符联系题" class="headerlink" title="1. 运算符联系题"></a>1. 运算符联系题</h1><p>练习1 ： 有两个变量，a和b，要求将其进行交换，最终打印结果</p>
<p>  <code>var a = 10</code></p>
<p>  <code>var b = 34</code></p>
<p>  <code>t := a</code></p>
<p>  <code>a = b</code></p>
<p>  <code>b = t</code></p>
<p>  <code>fmt.Println(a, b)</code></p>
<p>结果为34 10</p>
<p>定义一个中间变量t储存a的值</p>
<p>练习2：依旧是上面问题，但是不能使用中间变量方法</p>
<p>我的方法：</p>
<p>直接对a,b同时赋值对方的值</p>
<p>  <code>var a = 10</code></p>
<p>  <code>var b = 34</code></p>
<p>  <code>fmt.Println(a, b)</code></p>
<p>  <code>a, b = b, a</code></p>
<p>  <code>fmt.Println(a, b)</code></p>
<p>示范方法：</p>
<p>  <code>var a = 10</code></p>
<p>  <code>var b = 34</code></p>
<p>  <code>a = a + b</code></p>
<p>  <code>b = a - b</code></p>
<p>  <code>a = a - b</code></p>
<p>  <code>fmt.Println(a, b)</code></p>
<p>练习3： 假如还有100天放假，还剩多少个星期余多少天？</p>
<p>(一个星期7天)</p>
<p>  <code>var a = 100</code></p>
<p>  <code>var b = 7</code></p>
<p>  <code>c := a / b</code></p>
<p>  <code>d := a % b</code></p>
<p>  <code>fmt.Printf(&quot;还剩%v个星期%v天&quot;, c, d)</code></p>
<p>结果为：还剩14个星期2天</p>
<h1 id="2-位运算符-了解"><a href="#2-位运算符-了解" class="headerlink" title="2. 位运算符(了解)"></a>2. 位运算符(了解)</h1><p>位运算符对整数在内存中的二进制位进行操作</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>示例</th>
<th>含义说明</th>
<th>适用类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>a &amp; b</code></td>
<td>对应二进制位都为 1 时结果为 1</td>
<td>整数类型</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>a | b</td>
<td>两数有一个为1时结果为1</td>
<td>整数类型</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>a ^ b</code></td>
<td>对应二进制位不同为 1，相同为 0</td>
<td>整数类型</td>
</tr>
<tr>
<td><code>&amp;^</code></td>
<td>按位清零（AND NOT）</td>
<td><code>a &amp;^ b</code></td>
<td>将 <code>a</code> 中对应 <code>b</code> 为 1 的位清零，其余位保持不变</td>
<td>整数类型</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>a &lt;&lt; 2</code></td>
<td>将 <code>a</code> 的二进制位左移 2 位，高位丢弃，低位补 0</td>
<td>整数类型</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>a &gt;&gt; 2</code></td>
<td>将 <code>a</code> 的二进制位右移 2 位，符号位保持（有符号数）</td>
<td>整数类型</td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code>a := 6  // 0110
b := 3  // 0011

fmt.Println(&quot;a &amp; b =&quot;, a &amp; b)   // 2  -&gt; 0010
fmt.Println(&quot;a | b =&quot;, a | b)   // 7  -&gt; 0111
fmt.Println(&quot;a ^ b =&quot;, a ^ b)   // 5  -&gt; 0101
fmt.Println(&quot;a &amp;^ b =&quot;, a &amp;^ b) // 4  -&gt; 010
</code></pre>
<p>也就是将十进制的数转化为二进制进行同位的运算</p>
<p>左移</p>
<p>  <code>a := 6 // 0110</code></p>
<p>  <code>a = a &lt;&lt; 2</code></p>
<p>  <code>fmt.Println(a)</code></p>
<p>左移相当于乘以2的n次方，上面结果为24</p>
<p>右移</p>
<p>​    <code>a := 10      // 二进制 1010`   `fmt.Println(a &gt;&gt; 1) // 10 / 2 = 5`   `fmt.Println(a &gt;&gt; 2) // 10 / 4 = 2  （丢掉小数 0.5）`   `fmt.Println(a &gt;&gt; 3) // 10 / 8 = 1  （丢掉小数 0.25）</code></p>
<p>右移代表整除2的n次方，即右移只保留商的整数部分</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/05/Day11/" data-id="cmgdp1gwh0000zod14zi99ip2" data-title="GO语言教程Day11" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%83%E4%B9%A0%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/" rel="tag">运算符练习，位运算符</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Day10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/05/Day10/" class="article-date">
  <time class="dt-published" datetime="2025-10-05T09:56:24.000Z" itemprop="datePublished">2025-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/05/Day10/">GO语言教程Day10</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-go语言内置的运算符"><a href="#1-go语言内置的运算符" class="headerlink" title="1. go语言内置的运算符"></a>1. go语言内置的运算符</h1><h3 id="1-1-算数运算符"><a href="#1-1-算数运算符" class="headerlink" title="1.1 算数运算符"></a>1.1 算数运算符</h3><p>加 减 乘 除 取余&#x2F;&#x2F; + - * &#x2F; %</p>
<p>  <code>var a, b = 7, 3</code></p>
<p>  <code>fmt.Println(a+b, a-b, a*b, a/b, a%b)</code></p>
<p>输出结果为 10 4 21 2 1</p>
<p>除法注意，如果运算的数都是整数。除后，去掉小数部分，<strong>只保留整数部分</strong></p>
<p>当公式中出现常量的时候，<strong>系统会自动统一变量和常量的类型</strong>，如：</p>
<p><code>fmt.Println(10.0/10)</code></p>
<p>代码不会报错，而是统一为浮点数运行(10&#x2F;10.0一样结果为浮点数)</p>
<p>如果运算变量都是浮点数(<strong>注意，浮点数只能和浮点数运算，否则会报错</strong>)，运算结果同样为浮点数，例如：</p>
<p>  <code>var a, b = 7.0, 3.0</code></p>
<p>  <code>fmt.Println(a / b)</code></p>
<p>结果为 2.3333333333333335</p>
<p><strong>go语言浮点数不能用取余计算</strong></p>
<p>负数的取余计算：</p>
<p>  <code>fmt.Println(-10 % 3)</code></p>
<p>  <code>fmt.Println(10 % -3)</code></p>
<p>输出结果为 -1 1  计算方法为 余数&#x3D;被除数- (被除数&#x2F;除数)*除数</p>
<table>
<thead>
<tr>
<th>被除数 (a)</th>
<th>除数 (b)</th>
<th>表达式</th>
<th>结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+5</td>
<td>+2</td>
<td>5 % 2</td>
<td><strong>+1</strong></td>
<td>都是正数</td>
</tr>
<tr>
<td>+5</td>
<td>-2</td>
<td>5 % -2</td>
<td><strong>+1</strong></td>
<td>结果跟被除数一样是正数</td>
</tr>
<tr>
<td>-5</td>
<td>+2</td>
<td>-5 % 2</td>
<td><strong>-1</strong></td>
<td>结果跟被除数一样是负数</td>
</tr>
<tr>
<td>-5</td>
<td>-2</td>
<td>-5 % -2</td>
<td><strong>-1</strong></td>
<td>结果跟被除数一样是负数</td>
</tr>
</tbody></table>
<p>可以总结一个口诀： <strong>余数看左边，符号随被除</strong></p>
<p>也就是把被除数和除数按照绝对值运算，最后， 被除数的符号和余数的符号一致，确定余数的符号</p>
<h3 id="1-2-go的自增自减运算"><a href="#1-2-go的自增自减运算" class="headerlink" title="1.2 go的自增自减运算"></a>1.2 go的自增自减运算</h3><p>在go中，++ – 只能独立使用：</p>
<p>  <code>var i = 8</code></p>
<p>  <code>var a int</code> </p>
<p>  <code>a := i++</code></p>
<p>这是错误的写法，自增自减是单独的运算符，不能和赋值运算符一起运算(在其他语言可以)，上面语句对a进行赋值，在go语言里是不行的</p>
<p>在go中，++ –只能放在后面，比如 a++ </p>
<p>  <code>var a = 12</code></p>
<p>  <code>a++</code></p>
<p><code>//a--</code></p>
<p>  <code>fmt.Println(a)</code></p>
<p>结果为13， 在go语言里，自增自减只能<strong>单独使用</strong></p>
<h3 id="1-3-go的关系运算符"><a href="#1-3-go的关系运算符" class="headerlink" title="1.3 go的关系运算符"></a>1.3 go的关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>示例</th>
<th>结果说明</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>等于（Equal to）</td>
<td><code>a == b</code></td>
<td>若 <code>a</code> 等于 <code>b</code>，结果为 <code>true</code>，否则为 <code>false</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于（Not equal to）</td>
<td><code>a != b</code></td>
<td>若 <code>a</code> 不等于 <code>b</code>，结果为 <code>true</code>，否则为 <code>false</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于（Greater than）</td>
<td><code>a &gt; b</code></td>
<td>若 <code>a</code> 大于 <code>b</code>，结果为 <code>true</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于（Less than）</td>
<td><code>a &lt; b</code></td>
<td>若 <code>a</code> 小于 <code>b</code>，结果为 <code>true</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于（Greater than or equal to）</td>
<td><code>a &gt;= b</code></td>
<td>若 <code>a</code> 大于或等于 <code>b</code>，结果为 <code>true</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于（Less than or equal to）</td>
<td><code>a &lt;= b</code></td>
<td>若 <code>a</code> 小于或等于 <code>b</code>，结果为 <code>true</code></td>
<td><code>bool</code></td>
</tr>
</tbody></table>
<p>示例：</p>
<p>  <code>var a = 9</code></p>
<p>  <code>var b = 10</code></p>
<p>  <code>fmt.Println(a &gt; b)</code></p>
<p>结果为false，输出的结果为bool类型</p>
<p>注意，我们依旧要保证 a b 数据类型保持一致</p>
<p>主要用于条件判断的语句，例如：</p>
<p>  <code>var a = 9</code></p>
<p>  <code>var b = 10</code></p>
<p>  <code>flag := a &lt; b</code></p>
<p>  <code>if flag &#123;</code></p>
<p>​    <code>fmt.Println(&quot;a&lt;b&quot;)</code></p>
<p>  <code>&#125;</code></p>
<p>判断结果为true，if语句运行，打印出a&lt;b，如果判断结果为false，if语句不会运行</p>
<h3 id="1-4-go-中的逻辑运算符"><a href="#1-4-go-中的逻辑运算符" class="headerlink" title="1.4 go 中的逻辑运算符"></a>1.4 go 中的逻辑运算符</h3><h4 id="and-符号为"><a href="#and-符号为" class="headerlink" title="and 符号为 &amp;&amp;"></a>and 符号为 &amp;&amp;</h4><p>类似于 乘 ，只要有一方为false，输出的结果为false</p>
<p>  <code>var a = 15</code></p>
<p>  <code>var b = 10</code></p>
<p>  <code>fmt.Println(a &lt; 20 &amp;&amp; b &gt; 20)</code></p>
<p>结果为false</p>
<h4 id="or-符号为"><a href="#or-符号为" class="headerlink" title="or 符号为 ||"></a>or 符号为 ||</h4><p>类似于加</p>
<p>  <code>var a = 15</code></p>
<p>  <code>var b = 10</code></p>
<p>  <code>fmt.Println(a &lt; 20 || b &gt; 20)</code></p>
<p>结果为true</p>
<h4 id="not-符号为-！"><a href="#not-符号为-！" class="headerlink" title="not 符号为 ！"></a>not 符号为 ！</h4><p>取反</p>
<p>  <code>var a = true</code></p>
<p>  <code>fmt.Println(!a)</code></p>
<p>结果为false</p>
<h4 id="逻辑与和逻辑或-短路"><a href="#逻辑与和逻辑或-短路" class="headerlink" title="逻辑与和逻辑或 短路"></a>逻辑与和逻辑或 短路</h4><p>and前面为true，会继续执行后面</p>
<p><code>func test() bool&#123;</code></p>
<p>  <code>fmt.Println(&quot;test...&quot;)</code></p>
<p>  <code>return true</code></p>
<p><code>&#125;</code></p>
<p>  <code>var a = 9</code></p>
<p>  <code>if a&gt;8 &amp;&amp; test()&#123;</code></p>
<p>​    <code>fmt.Println(&quot;执行&quot;)</code></p>
<p>定义了 test方法， a&gt;8显然是true，代码先执行了test方法，然后执行了if的语句，结果为</p>
<p>test…<br>执行</p>
<p>如果将条件改为a&gt;10，则什么都不会运行，<strong>相当于前面的条件短路了test方法</strong></p>
<p>or 与 and 有些不同：</p>
<p>  var a &#x3D; 9</p>
<p>  if a &gt; 10 || test() {</p>
<p>​    fmt.Println(“执行”)</p>
<p>可以看到，前面结果为false，依旧运行了后面的代码</p>
<p>此时代码的运行结果为</p>
<p>test…<br>执行</p>
<p>我们可以这样分析上面代码：</p>
<p>首先 a&gt;10，产生了false，由于逻辑运算符是or，必须运行test才能知道运不运行if语句，运行test后，返回true，此时or运算通过，再运行if</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>左边结果</th>
<th>是否执行右边</th>
<th>整体结果</th>
<th>口诀</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与（AND）</td>
<td><code>false</code></td>
<td>❌ 不执行右边</td>
<td>一定 <code>false</code></td>
<td>“与假短路” &#x2F; “左假右不看”</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与（AND）</td>
<td><code>true</code></td>
<td>✅ 执行右边</td>
<td>看右边结果</td>
<td>“都真才真”</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>false</td>
<td>✅ 执行右边</td>
<td>看右边结果</td>
<td>右边真则运行，假则不运行</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>true</td>
<td>❌ 不执行右边</td>
<td>一定为true</td>
<td>左真则运行</td>
</tr>
</tbody></table>
<p>即 <strong>如果左边第一个判断可以直接导出整体结果，则不会运行右边判断，直接判断是否运行if语句</strong></p>
<h3 id="1-5-赋值运算符"><a href="#1-5-赋值运算符" class="headerlink" title="1.5 赋值运算符"></a>1.5 赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>类型</th>
<th>示例</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>基本赋值</td>
<td><code>a = b</code></td>
<td>将右边的值赋给左边变量</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加并赋值</td>
<td><code>a += b</code></td>
<td>等同于 <code>a = a + b</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减并赋值</td>
<td><code>a -= b</code></td>
<td>等同于 <code>a = a - b</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘并赋值</td>
<td><code>a *= b</code></td>
<td>等同于 <code>a = a * b</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除并赋值</td>
<td><code>a /= b</code></td>
<td>等同于 <code>a = a / b</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取余并赋值</td>
<td><code>a %= b</code></td>
<td>等同于 <code>a = a % b</code>（仅适用于整数）</td>
</tr>
</tbody></table>
<p>  <code>var a = 20</code></p>
<p>  <code>b := 20</code></p>
<p>  <code>a += b</code></p>
<p>  <code>fmt.Println(a, b)</code></p>
<p>此时结果为 40 20</p>
<p><code>var a = 23 + 2</code></p>
<p>go语言会先运算+ - * &#x2F;，所以对a的赋值为25</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/05/Day10/" data-id="cmgdp1gwl0001zod18vn5gkyr" data-title="GO语言教程Day10" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/" rel="tag">go语言的运算符</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Day9" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/24/Day9/" class="article-date">
  <time class="dt-published" datetime="2025-09-24T13:29:13.000Z" itemprop="datePublished">2025-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/24/Day9/">GO语言教程Day9</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-数值类型的转换"><a href="#1-数值类型的转换" class="headerlink" title="1. 数值类型的转换"></a>1. 数值类型的转换</h1><h2 id="1-1-int8与int16之间的转换"><a href="#1-1-int8与int16之间的转换" class="headerlink" title="1.1 int8与int16之间的转换"></a>1.1 int8与int16之间的转换</h2><h2 id="1-2-float32和float64之间的转换"><a href="#1-2-float32和float64之间的转换" class="headerlink" title="1.2 float32和float64之间的转换"></a>1.2 float32和float64之间的转换</h2><h2 id="1-3-整型和浮点型之间的转换"><a href="#1-3-整型和浮点型之间的转换" class="headerlink" title="1.3 整型和浮点型之间的转换"></a>1.3 整型和浮点型之间的转换</h2><p>建议将整型转化为浮点型</p>
<h1 id="2-其他类型转换为String类型"><a href="#2-其他类型转换为String类型" class="headerlink" title="2. 其他类型转换为String类型"></a>2. 其他类型转换为String类型</h1><h2 id="2-1-Sprintf转换"><a href="#2-1-Sprintf转换" class="headerlink" title="2.1 Sprintf转换"></a>2.1 Sprintf转换</h2><p>在前面的教程中，Sprintf用于分割，拼接等，在golang中 fmt.Sprintf也可以将其他类型转换为Strings类型</p>
<h3 id="int类型转换为String类型"><a href="#int类型转换为String类型" class="headerlink" title="int类型转换为String类型"></a>int类型转换为String类型</h3><p>  <code>var a int = 20</code></p>
<p>  <code>str1 := fmt.Sprintf(&quot;%d&quot;, a)</code></p>
<p>  <code>fmt.Printf(&quot;值%v 类型%T&quot;, str1, str1)</code></p>
<p>%d表示将a以十进制输出，此时输出的是string类型的数据，输出为 值20 类型string</p>
<h3 id="float类型转换为String类型"><a href="#float类型转换为String类型" class="headerlink" title="float类型转换为String类型"></a>float类型转换为String类型</h3><p>  <code>var b float64 = 12.123</code></p>
<p>  <code>str2 := fmt.Sprintf(&quot;%f&quot;, b)</code></p>
<p>  <code>fmt.Printf(&quot;值%v 类型%T&quot;, str2, str2)</code></p>
<p>此时输出为 值12.123000 类型string</p>
<p>类似的，bool类型转化为String类型是**%t**，得到的结果是字符串true</p>
<p>字符转化为String类型是**%c**，原样输出，前面也有提到</p>
<h2 id="2-2-使用strconv包里面的几种转换方法转换"><a href="#2-2-使用strconv包里面的几种转换方法转换" class="headerlink" title="2.2 使用strconv包里面的几种转换方法转换"></a>2.2 使用strconv包里面的几种转换方法转换</h2><p>  <code>var a int = 20</code></p>
<p>  <code>var b float64 = 12.123</code></p>
<p>  <code>var c bool = true</code></p>
<p>  <code>var d byte = &#39;a&#39;</code></p>
<p>  <code>str1 := strconv.FormatInt(int64(a), 10)</code></p>
<p>  <code>str2 := strconv.FormatFloat(b, &#39;f&#39;, 2, 64)</code></p>
<p>  <code>str3 := strconv.FormatBool(c)</code></p>
<p>  <code>str4 := strconv.FormatUint(uint64(d), 10)</code></p>
<p>  <code>fmt.Printf(&quot;%T %T %T %T&quot;, str1, str2, str3, str4)</code></p>
<p>输出为 string string string string</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>函数</th>
<th>功能</th>
<th>参数说明</th>
<th>返回值</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>整数</strong></td>
<td><code>strconv.Itoa(i int) string</code></td>
<td>整数 → 字符串</td>
<td><code>i</code>：整型</td>
<td><code>string</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>strconv.Atoi(s string) (int, error)</code></td>
<td>字符串 → 整数</td>
<td><code>s</code>：十进制字符串</td>
<td><code>int</code>, <code>error</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong><code>strconv.FormatInt(i int64, base int) string</code></strong></td>
<td>int64 → 指定进制字符串</td>
<td><code>i</code>：整数<code>base</code>：进制(2~36)</td>
<td><code>string</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>strconv.ParseInt(s string, base int, bitSize int) (int64, error)</code></td>
<td>字符串 → int64</td>
<td><code>s</code>：字符串<code>base</code>：进制<code>bitSize</code>：位数(0,8,16,32,64)</td>
<td><code>int64</code>, <code>error</code></td>
<td></td>
</tr>
<tr>
<td><strong>浮点</strong></td>
<td><strong><code>strconv.FormatFloat(f float64, fmt byte, prec, bitSize int) string</code></strong></td>
<td>浮点数 → 字符串</td>
<td><code>f</code>：浮点数<code>fmt</code>：格式(<code>b,e,f,g</code>)<code>prec</code>：精度（保留位数）<code>bitSize</code>：32或64</td>
<td><code>string</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>strconv.ParseFloat(s string, bitSize int) (float64, error)</code></td>
<td>字符串 → 浮点数</td>
<td><code>s</code>：字符串<code>bitSize</code>：32或64</td>
<td><code>float64</code>, <code>error</code></td>
<td></td>
</tr>
<tr>
<td><strong>布尔</strong></td>
<td><strong><code>strconv.FormatBool(b bool) string</code></strong></td>
<td>布尔 → 字符串</td>
<td><code>b</code>：布尔值</td>
<td><code>&quot;true&quot;</code> 或 <code>&quot;false&quot;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>strconv.ParseBool(s string) (bool, error)</code></td>
<td>字符串 → 布尔</td>
<td><code>s</code>：可识别 <code>&quot;1&quot; &quot;t&quot; &quot;true&quot;</code> 等</td>
<td><code>bool</code>, <code>error</code></td>
<td></td>
</tr>
<tr>
<td><strong>字符</strong></td>
<td><strong><code>strconv.FormatUint(i s) string</code></strong></td>
<td>byte → 字符串</td>
<td>&#96;i：单个字符 s: 进制</td>
<td>例如 <code>&#39;你&#39;</code> → <code>&quot;你&quot;</code></td>
<td></td>
</tr>
</tbody></table>
<p>当然，你也可以用如下方法转换字符为字符串，这样可能会更加简单：</p>
<p>  <code>var d byte = &#39;a&#39;</code></p>
<p>  <code>e := string(d)</code></p>
<p>  <code>fmt.Printf(&quot;类型是%T,数值是%v&quot;, e, e)</code></p>
<p>输出的结果为 类型是string,数值是a</p>
<h3 id="2-3-string类型转化为int类型"><a href="#2-3-string类型转化为int类型" class="headerlink" title="2.3 string类型转化为int类型"></a>2.3 string类型转化为int类型</h3><p>使用strconv.ParseInt() 有几个参数类型 第一个是转换的<strong>变量名称</strong>，第二是<strong>转化的进制</strong>，最后一位是转<strong>化成32位或者64位</strong></p>
<p>  <code>var a = &quot;21&quot;</code></p>
<p>  <code>b, _ := strconv.ParseInt(a, 10, 64)</code></p>
<p>  <code>fmt.Println(b)</code></p>
<p>注意，strconv.ParseInt输出了<strong>两个值</strong>，第一个是转化的数值，第二个是err是否转化错误，我们可以用匿名变量来输出，但不使用</p>
<p>上面的输出为 21</p>
<p>如果转化的字符串中不是数字(其中有其他字符），就会返回一个64位的<strong>0</strong>，此时err会返回一串报错的字符</p>
<h3 id="2-4-string类型转化为float类型"><a href="#2-4-string类型转化为float类型" class="headerlink" title="2.4 string类型转化为float类型"></a>2.4 string类型转化为float类型</h3><p>使用strconv.ParseFloat 第一个是转换的<strong>变量名称</strong>，第二是<strong>转化的位数</strong> 32位或者64位</p>
<p>  <code>var a = &quot;1.321321&quot;</code></p>
<p>  <code>b, _ := strconv.ParseFloat(a, 64)</code></p>
<p>  <code>fmt.Printf(&quot;%v,%T&quot;, b, b)</code></p>
<p>输出结果为 1.321321,float64</p>
<p>如果有无法转换的字符，同样会输出<strong>0</strong></p>
<h3 id="2-5-数值类型和bool类型"><a href="#2-5-数值类型和bool类型" class="headerlink" title="2.5 数值类型和bool类型"></a>2.5 数值类型和bool类型</h3><p>数值类型无法转换为bool类型，bool类型也无法转化为数值类型，否则会发生报错</p>
<h3 id="2-6-string类型转化为bool型"><a href="#2-6-string类型转化为bool型" class="headerlink" title="2.6 string类型转化为bool型"></a>2.6 string类型转化为bool型</h3><p>不建议，使用strconv.ParseBool，该代码只有一个参数</p>
<p>  <code>b, _ := strconv.ParseBool(&quot;true&quot;)</code></p>
<p>  <code>fmt.Printf(&quot;%v,%T&quot;, b, b)</code></p>
<p>运行上面代码，结果为true，bool</p>
<p><strong>如果定义的字符串，内容不是true 或者 false，则会返回false</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/24/Day9/" data-id="cmfy3cefa0000ogd12riv14xe" data-title="GO语言教程Day9" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GOlang%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/" rel="tag">GOlang中基本数据类型之间的转换</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Day8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/23/Day8/" class="article-date">
  <time class="dt-published" datetime="2025-09-23T13:23:03.000Z" itemprop="datePublished">2025-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/23/Day8/">GO语言教程Day8</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-byte和rune类型"><a href="#1-byte和rune类型" class="headerlink" title="1.byte和rune类型"></a>1.byte和rune类型</h1><p>组成每个字符串的元素叫”字符“，可以通过便利字符串元素获得字符，字符用单引号(‘’)包裹</p>
<h3 id="如何定义一个字符"><a href="#如何定义一个字符" class="headerlink" title="如何定义一个字符"></a>如何定义一个字符</h3><p>字符属于int类型</p>
<p><code>var a =&#39;a&#39;</code> 这么定义是正确的</p>
<p><code>var a =&#39;aa&#39;</code> 这么定义是错误的，byte类型只能含有一个元素</p>
<p>  <code>var a = &#39;a&#39;</code></p>
<p>  <code>fmt.Printf(&quot;类型是%T,字符是%v&quot;, a, a)</code></p>
<p>得到的结果是类型是int32,字符是97</p>
<p>可见，默认输出的结果是a对应的ASCII码的值，类型是int32</p>
<h4 id="如何原样输出a"><a href="#如何原样输出a" class="headerlink" title="如何原样输出a?"></a>如何原样输出a?</h4><p>使用%c来原样输出a：</p>
<p>  var a &#x3D; ‘a’</p>
<p>  fmt.Printf(“类型是%T,字符是%c”, a, a)</p>
<h4 id="Go-语言的字符有以下两种："><a href="#Go-语言的字符有以下两种：" class="headerlink" title="Go 语言的字符有以下两种："></a>Go 语言的字符有以下两种：</h4><ol>
<li>uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。</li>
<li>rune 类型，代表一个 UTF-8 字符。</li>
</ol>
<p>定义一个字符串，输出字符串里面的字符：</p>
<p>  <code>var str = &quot;This&quot;</code></p>
<p>  <code>fmt.Printf(&quot;值：%v,类型：%T&quot;, str[1], str[1])</code></p>
<p>取到了字符h，对应105。在golang中，一个字母(ASCII)占用一个字节的空间，一个汉字(UTF-8)占用三个字节的空间</p>
<h3 id="查看字符串中占用存储空间"><a href="#查看字符串中占用存储空间" class="headerlink" title="查看字符串中占用存储空间"></a>查看字符串中占用存储空间</h3><p>前面介绍过unsafe,sizeof查看int，float类型等的大小，但是对于字符串来说，这是行不通的，无论我们的字符串有多长，都只会返回<strong>16</strong>：</p>
<p>在 Go 里，<strong>字符串 (string)</strong> 本质上并不是直接存储字符数组，而是一个 <strong>结构体</strong>，它包含两个字段：</p>
<p><code>type stringStruct struct &#123;</code><br>    <code>str unsafe.Pointer // 指向底层字节数组的指针</code><br>    <code>len int            // 字符串长度</code><br><code>&#125;</code></p>
<ul>
<li><code>str</code> 占 8 字节（64 位机器上指针大小 &#x3D; 8）</li>
<li><code>len</code> 占 8 字节（64 位机器上 int &#x3D; 8）</li>
</ul>
<p>所以总共就是 <strong>16 字节</strong>。</p>
<p>想获取字符串占用大小，可以用len直接获取字节数，这对于汉字也是可以用的，比如：</p>
<p>  <code>var a = &quot;数据&quot;</code></p>
<p>  <code>fmt.Println(len(a))</code></p>
<p>返回的值为6</p>
<h3 id="用字符定义一个汉字"><a href="#用字符定义一个汉字" class="headerlink" title="用字符定义一个汉字"></a>用字符定义一个汉字</h3><p>  <code>var a = &#39;数&#39;</code></p>
<p>  <code>fmt.Printf(&quot;值：%v,类型：%T&quot;, a, a)</code></p>
<p>得到的输出为 25968,类型：int32</p>
<p>因为golang中使用UTF-8来进行编码，在UTF-8中编码后使用的就是该值</p>
<h3 id="通过循环遍历字符串里的字符"><a href="#通过循环遍历字符串里的字符" class="headerlink" title="通过循环遍历字符串里的字符"></a>通过循环遍历字符串里的字符</h3><p>package main</p>
<p>import (<br>	“fmt”<br>)</p>
<p>func main() {<br>	s :&#x3D; “hello中国”</p>
<pre><code>// 1. len -&gt; 字节数
fmt.Println(&quot;len(s):&quot;, len(s)) // 11 (hello 5 + 中国 6)

// 2. []byte -&gt; 按字节切分
fmt.Println(&quot;[]byte(s):&quot;, []byte(s))

// 3. []rune -&gt; 按 Unicode 码点切分
fmt.Println(&quot;[]rune(s):&quot;, []rune(s))
fmt.Println(&quot;len([]rune(s)):&quot;, len([]rune(s)))

// 4. range -&gt; 按 rune 遍历
for i, r := range s &#123;
	fmt.Printf(&quot;index=%d, rune=%c, codepoint=%d\n&quot;, i, r, r)
&#125;
</code></pre>
<p>}</p>
<p>执行结果为：</p>
<p>len(s): 11<br>[]byte(s): [104 101 108 108 111 228 184 173 229 155 189]<br>[]rune(s): [104 101 108 108 111 20013 22269]<br>len([]rune(s)): 7<br>index&#x3D;0, rune&#x3D;h, codepoint&#x3D;104<br>index&#x3D;1, rune&#x3D;e, codepoint&#x3D;101<br>index&#x3D;2, rune&#x3D;l, codepoint&#x3D;108<br>index&#x3D;3, rune&#x3D;l, codepoint&#x3D;108<br>index&#x3D;4, rune&#x3D;o, codepoint&#x3D;111<br>index&#x3D;5, rune&#x3D;中, codepoint&#x3D;20013<br>index&#x3D;8, rune&#x3D;国, codepoint&#x3D;22269</p>
<p>注意，rune的功能更强大，因为ASCII码是UTF-8的子集</p>
<h3 id="range和len的区别"><a href="#range和len的区别" class="headerlink" title="range和len的区别"></a>range和len的区别</h3><p>在用for循环打印字符串中的汉字时，打印出的根本不是其对应的UTF-8编码，为了彻底搞清楚这个问题，查阅了很多资料：</p>
<p>首先是go的字符串储存的方式：Go 的字符串底层 <strong>统一用 UTF-8 编码存储</strong></p>
<p>为什么用range能正常打印出汉字呢？</p>
<p>因为range 数的是字符，而len数的是字节，以下是他们的区别：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>返回&#x2F;处理对象</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>len(s)</code></td>
<td><strong>字节数</strong></td>
<td>返回 UTF-8 编码后占用多少字节，不涉及字符概念</td>
</tr>
<tr>
<td><code>s[i]</code></td>
<td><strong>第 i 个字节</strong></td>
<td>按字节取值，如果直接打印成 <code>%c</code>，可能显示“乱码”</td>
</tr>
<tr>
<td><code>range s</code></td>
<td><strong>rune（字符&#x2F;码点）</strong></td>
<td>按 UTF-8 解码，逐个返回完整的字符（Unicode 码点）</td>
</tr>
</tbody></table>
<p>此外，如果直接打印字符的值，得到的是一个五位数，而循环打印，得到的是三个三位数，这是为什么？</p>
<p>比如：</p>
<p>  <code>s := &quot;中&quot;</code></p>
<p>  <code>s1 := &#39;中&#39;</code></p>
<p>  <code>fmt.Printf(&quot;%v\n&quot;, s1)</code></p>
<p>  <code>for i := 0; i &lt; len(s); i++ &#123;</code></p>
<p>​    <code>fmt.Printf(&quot;%v &quot;, s[i])</code></p>
<p>  <code>&#125;</code></p>
<p>得到的输出是：</p>
<p>20013<br>228 184 173 </p>
<table>
<thead>
<tr>
<th>打印方式</th>
<th>访问对象</th>
<th>输出</th>
<th>为什么</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]rune(s)</code> 或 <code>range</code></td>
<td>Unicode 码点</td>
<td>20013（五位数）</td>
<td>rune 表示完整字符的码点值</td>
</tr>
<tr>
<td>按字节循环 <code>s[i]</code></td>
<td>UTF-8 字节</td>
<td>228, 184, 173（三位数）</td>
<td>UTF-8 把一个字符编码成多个字节，每个字节单独打印就是单个整数</td>
</tr>
</tbody></table>
<p>每个字符都有一个唯一的 Unicode 码点，例如 <code>&quot;中&quot;</code> 的码点是 20013（十进制）。<br> 在 UTF-8 编码下，它占用 3 个字节 <code>[228 184 173]</code>（其他编码方式可能不同）。<br> 当使用 <code>range</code> 或转换成 <code>[]rune</code> 遍历字符串时，程序会把 UTF-8 字节序列解码成对应的码点，再用 <code>%c</code> 打印时显示对应字符。<br> 而如果用按字节循环（如 <code>for i := 0; i &lt; len(s); i++</code>）逐个打印，就只能看到 UTF-8 的原始字节值 <code>[228 184 173]</code>，所以看起来像“三个三位数”</p>
<p>一句话而言：range是按字符，而len是按字节</p>
<h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成[]rune 或[]byte，完成后再转换为 string。无论哪种转换，<br>都会重新分配内存，并复制字节数组。</p>
<p>我们想要将big中的b改为p，想到用下面的方法</p>
<p>  <code>s1 :=&quot;big&quot;</code></p>
<p>  <code>s1[0] = &#39;p&#39;</code></p>
<p>  <code>fmt.Println(s1)</code></p>
<p>然而结果会直接报错，这是因为GO语言规定：<code>s1</code> 是 <strong>string</strong> 类型，本质上是一个不可变的字节序列</p>
<p>这里有一些关于byte的小常识：</p>
<p>byte只能处理单个字节，byte的本质是0-255的整数，是ASCII码的别名，  <strong>也就是当我们定义或者取字符的时候，实际上定义或者取的是0-255的一个数</strong>，所以只能接收字符常量或整数值，不能直接转换整个字符串。如果要处理字符串，要么取单个索引（<code>s[0]</code>），要么转成 <code>[]byte</code></p>
<p><code>a := byte(&#39;a&#39;)</code></p>
<p>  <code>fmt.Println(a)</code></p>
<p>  <code>b := byte(255)</code></p>
<p>  <code>fmt.Println(b)</code></p>
<p>以上两种是可以直接用byte转化的例子，得到的结果为</p>
<p>97<br>255</p>
<p>我们想修改字符串，可以定义切片，修改切片，最后转化为string类型再输出，例如：</p>
<p>  <code>str := &quot;big&quot;</code></p>
<p>  <code>strChange := []byte(str)</code></p>
<p>  <code>strChange[0] = &#39;p&#39;</code></p>
<p>  <code>fmt.Println(string(strChange))</code></p>
<p>这里我们有常识：<strong>切片里面的每个数字都对应一个字符</strong>，可以通过string来转化为字符串</p>
<p>比如这个代码，它转化过程就是先把big转化为切片，取切片的第一个元素，用一个新的字符更改，最后再转化为字符串输出，如果最后一行没有string转换，输出的是[112 105 103]。</p>
<h4 id="如果字符串中含有汉字呢？"><a href="#如果字符串中含有汉字呢？" class="headerlink" title="如果字符串中含有汉字呢？"></a>如果字符串中含有汉字呢？</h4><p>我们使用rune来转换：</p>
<p>  <code>str := &quot;你 好,big&quot;</code></p>
<p>  <code>strChange := []rune(str)</code></p>
<p>  <code>strChange[0] = &#39;大&#39;</code></p>
<p>  <code>strChange[1] = &#39;家&#39;</code></p>
<p>  <code>fmt.Println(string(strChange))</code></p>
<p>最后得到的输出为 大家好,big</p>
<p>当然，如果全为字母，<strong>也可以直接使用rune转换</strong>，所以说rune比byte功能更强大</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/23/Day8/" data-id="cmfwow39u0000pwd11nk71t4i" data-title="GO语言教程Day8" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/" rel="tag">byte类型和rune类型</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Day7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/22/Day7/" class="article-date">
  <time class="dt-published" datetime="2025-09-22T13:05:51.000Z" itemprop="datePublished">2025-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/22/Day7/">GO语言教程Day7</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h1><p>字符串的值<br>为双引号(“)中的内容，可以在 Go 语言的源码中直接添加非 ASCII 码字符</p>
<h2 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>名称</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\r</code></td>
<td>回车符 (Carriage Return)</td>
<td>光标返回行首，不换行</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符 (Line Feed)</td>
<td>光标移到下一行同一列</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符 (Tab)</td>
<td>插入水平制表位，相当于若干空格</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号 (Single Quote)</td>
<td>表示字符 <code>&#39;</code></td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号 (Double Quote)</td>
<td>表示字符 <code>&quot;</code></td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠 (Backslash)</td>
<td>表示字符 <code>\</code> 本身</td>
</tr>
</tbody></table>
<p>在GO语言中，\是关键词，如果想输出\，<strong>比如输出路径时</strong>，可以选择两个斜杠来表示一个斜杠，比如：</p>
<p>  <code>str2 := &quot;D:\\blog\\myblog\\source\\_posts&quot;</code></p>
<p>  <code>fmt.Println(str2)</code></p>
<p>得到的输出结果为：D:\blog\myblog\source_posts</p>
<p>此结果只把双斜杠输出成了单斜杠</p>
<p>如果想输出的内容中带有引号，由于引号也是关键词，可以采用如下方法：</p>
<p><strong>我们想要输出c:go “1”</strong></p>
<p>  <code>str := &quot;c:go \&quot;1\&quot;&quot;</code>  </p>
<p>  <code>fmt.Println(str)</code></p>
<p>得到的输出结果为 c:go “1”，不含有斜杠</p>
<p>在关键符号前面加一个斜杠\用于转义</p>
<h3 id="一次定义多行字符串字符串"><a href="#一次定义多行字符串字符串" class="headerlink" title="一次定义多行字符串字符串"></a>一次定义多行字符串字符串</h3><p>双引号一次只能定义一行的字符串，如果字符串是多行，就必须使用反引号字符：</p>
<p>  <code>str1 := </code>This is&#96; </p>
<p>  <code>a str</code></p>
<p>  <code>fmt.Println(str1)</code></p>
<p>可以正常输出This is<br>        a str</p>
<p>使用tab键上面的键，即反引号来定义多行字符串</p>
<h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table>
<thead>
<tr>
<th>函数&#x2F;用法</th>
<th>功能说明</th>
<th>示例</th>
<th>返回值&#x2F;结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>len(str)</code></td>
<td>获取字符串长度（字节数）</td>
<td><code>len(&quot;hello&quot;)</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>+</code> 或 <code>fmt.Sprintf</code></td>
<td>字符串拼接</td>
<td><code>&quot;Go&quot; + &quot;Lang&quot;</code> &#x2F; <code>fmt.Sprintf(&quot;%s-%s&quot;, &quot;Go&quot;, &quot;Lang&quot;)</code></td>
<td><code>&quot;GoLang&quot;</code> &#x2F; <code>&quot;Go-Lang&quot;</code></td>
</tr>
<tr>
<td><code>strings.Split(s, sep)</code></td>
<td>按分隔符切分字符串，返回切片</td>
<td><code>strings.Split(&quot;a,b,c&quot;, &quot;,&quot;)</code></td>
<td><code>[]string&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;</code></td>
</tr>
<tr>
<td><code>strings.Contains(s, substr)</code></td>
<td>判断是否包含子串</td>
<td><code>strings.Contains(&quot;hello&quot;, &quot;he&quot;)</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>strings.HasPrefix(s, prefix)</code></td>
<td>判断是否有指定前缀</td>
<td><code>strings.HasPrefix(&quot;golang&quot;, &quot;go&quot;)</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>strings.HasSuffix(s, suffix)</code></td>
<td>判断是否有指定后缀</td>
<td><code>strings.HasSuffix(&quot;test.txt&quot;, &quot;.txt&quot;)</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>strings.Index(s, substr)</code></td>
<td>子串首次出现的位置（找不到返回 <code>-1</code>）</td>
<td><code>strings.Index(&quot;banana&quot;, &quot;na&quot;)</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>strings.LastIndex(s, substr)</code></td>
<td>子串最后出现的位置</td>
<td><code>strings.LastIndex(&quot;banana&quot;, &quot;na&quot;)</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>strings.Join(a []string, sep string)</code></td>
<td>将切片用分隔符拼接成字符串</td>
<td><code>strings.Join([]string&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;, &quot;-&quot;)</code></td>
<td><code>&quot;a-b-c&quot;</code></td>
</tr>
</tbody></table>
<h3 id="求字符串的长度-len"><a href="#求字符串的长度-len" class="headerlink" title="求字符串的长度 len"></a>求字符串的长度 len</h3><p>  <code>str1 := &quot;你好&quot;</code></p>
<p>  <code>fmt.Println(len(str1))</code></p>
<p>运行以上代码，输出结果6。由于<strong>一个汉字占用3个字节</strong>，所以输出结果为6，如果str:&#x3D;”aaaa”，则输出结果会变为4，因为一个英语单词只占用1个字节。</p>
<h3 id="拼接字符串-fmt-sprintf"><a href="#拼接字符串-fmt-sprintf" class="headerlink" title="拼接字符串 +&#x2F;fmt.sprintf"></a>拼接字符串 +&#x2F;fmt.sprintf</h3><p>  <code>str1 := &quot;你&quot; + &quot;好&quot;</code></p>
<p>  <code>fmt.Println(str1)</code></p>
<p>+号在字符串中表示拼接操作，而在数值运算中表示加法相加</p>
<p>当进行多行的拼接操作时，+号跟在字符串的后面，此时打印也在同一行，例如：</p>
<p>  <code>str := &quot;反引号间换行将被作为字符串中的换行&quot; +</code></p>
<p><code>&quot;，但是所有的转义字符均无效&quot; +</code></p>
<p><code>&quot;，文本将会原样输出。&quot;</code></p>
<p>  <code>fmt.Println(str)</code></p>
<p>此时代码可以正常输出反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<p>  <code>str1 := &quot;你好&quot;</code></p>
<p>  <code>str2 := &quot;golang&quot;</code></p>
<p>  <code>str3 := fmt.Sprintf(&quot;%v %v&quot;, str1, str2)</code></p>
<p>  <code>fmt.Println(str3)</code></p>
<p>注意，str定义时不使用printf因为printf是一个打印的操作，而sprintf用来定义时候使用</p>
<h3 id="字符串的分割-Split"><a href="#字符串的分割-Split" class="headerlink" title="字符串的分割 Split"></a>字符串的分割 Split</h3><p>使用split前，需要引入strings包。运行如下代码</p>
<p>  <code>var a = &quot;123-456-789&quot;</code></p>
<p>  <code>arr := strings.Split(a, &quot;-&quot;)</code></p>
<p>  <code>fmt.Println(arr)</code></p>
<p>运行结果为[123 456 789]，split语法为，第一个位置表示要切个的字符串名称，第二个空格二表示按什么元素来切割，最后的结果实则是一个切片，但可以简单理解为得到了一个数组</p>
<h3 id="字符串的装引-join"><a href="#字符串的装引-join" class="headerlink" title="字符串的装引 join"></a>字符串的装引 join</h3><p>可以把一个切片连接为字符串，join的语法为第一个位置表示要装引的切片，第二个位置为用什么来连接，例如：</p>
<p>  <code>var a = &quot;123-456-789&quot;</code></p>
<p>  <code>arr := strings.Split(a, &quot;-&quot;)</code></p>
<p>  <code>str := strings.Join(arr, &quot;*&quot;)</code></p>
<p>  <code>fmt.Printf(&quot;内容是%v,类型是%T&quot;, str, str)</code></p>
<p>最后得到的输出为<code>内容是123*456*789,类型是string</code></p>
<p>当然也可以直接定义一个切片(切片是一种复合数据类型），后面会介绍：</p>
<p>  <code>arr := []string&#123;&quot;php&quot;, &quot;java&quot;, &quot;golang&quot;&#125;</code></p>
<p>  <code>str := strings.Join(arr, &quot;*&quot;)</code></p>
<p>  <code>fmt.Printf(&quot;结果是%v,类型是%T&quot;, str, str)</code></p>
<p>用”*“号将切片连接起来，得到的输出是 结果是<code>php*java*golang,类型是string</code></p>
<h3 id="判断字符串是否包含另一个字符串-contains"><a href="#判断字符串是否包含另一个字符串-contains" class="headerlink" title="判断字符串是否包含另一个字符串 contains"></a>判断字符串是否包含另一个字符串 contains</h3><p>contains是判断整个字符串是否包括后面位置的内容</p>
<p>  <code>str1 := &quot;This is str&quot;</code></p>
<p>  <code>str2 := &quot;This&quot;</code></p>
<p>  <code>flag := strings.Contains(str1, str2)</code></p>
<p>  <code>fmt.Println(flag)</code></p>
<p>contains的语法是第一个位置为原语句，第二个位置为是否被包含的语句，运行如上代码，结果为true</p>
<h3 id="前缀后缀判断-HasPrefix-HasSuffix"><a href="#前缀后缀判断-HasPrefix-HasSuffix" class="headerlink" title="前缀后缀判断 HasPrefix,HasSuffix"></a>前缀后缀判断 HasPrefix,HasSuffix</h3><p>看前端或后端是否有指定的字符串，HasPrefix,HasSuffix的用法和前面的contains相似</p>
<p>  <code>str1 := &quot;This is str&quot;</code></p>
<p>  <code>str2 := &quot;This&quot;</code></p>
<p>  <code>flag := strings.HasPrefix(str1, str2)</code></p>
<p>  <code>fmt.Println(flag)</code></p>
<p>得到的输出为true</p>
<h3 id="子串出现的位置-index和Lastindex"><a href="#子串出现的位置-index和Lastindex" class="headerlink" title="子串出现的位置 index和Lastindex"></a>子串出现的位置 index和Lastindex</h3><p>index计数方式是从前往后计数，查找字符串是否出现，如果出现，则返回位置：</p>
<p>  <code>str1 := &quot;This is str&quot;</code></p>
<p>  <code>str2 := &quot;is&quot;</code></p>
<p>  <code>num := strings.Index(str1, str2)</code></p>
<p>  <code>fmt.Println(num)</code></p>
<p>得到的返回值为2，注意，这里找到的is是This里含有的is，而index同样是从0开始计数</p>
<p>LastIndex同样是从前往后计数，但是是从后往前查找</p>
<p>  <code>str1 := &quot;This is str&quot;</code></p>
<p>  <code>str2 := &quot;is&quot;</code></p>
<p>  <code>num := strings.LastIndex(str1, str2)</code></p>
<p>  <code>fmt.Println(num)</code></p>
<p>得到的返回值为5</p>
<p>当index和Lastindex查找不到时，就会返回**-1**的值</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/22/Day7/" data-id="cmfv7fx3h0000xkd16ohm857b" data-title="GO语言教程Day7" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" rel="tag">字符串 字符串里面的方法详解</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Day6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/21/Day6/" class="article-date">
  <time class="dt-published" datetime="2025-09-21T12:57:27.000Z" itemprop="datePublished">2025-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/21/Day6/">GO语言教程Day6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-浮点型"><a href="#1-浮点型" class="headerlink" title="1. 浮点型"></a>1. 浮点型</h1><p>Go 语言支持两种浮点型数：float32 和 float64。这两种浮点型数据格式遵循 IEEE 754 标准：<br>float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的<br>浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</p>
<p>  <code>var num float32 = 3.14</code></p>
<p>  <code>fmt.Printf(&quot;num的值是%v----%f,num的类型是%T\n&quot;, num, num, num)</code></p>
<p>  <code>fmt.Println(unsafe.Sizeof(num))</code></p>
<p>%f默认保留六位小数，并且进行四舍五入，根据输出结果可知。float32占用4个字节</p>
<p>  <code>var num float64 = 3.14</code></p>
<p>  <code>fmt.Printf(&quot;num的值是%v----%f,num的类型是%T\n&quot;, num, num, num)</code></p>
<p>  <code>fmt.Println(unsafe.Sizeof(num))</code></p>
<p>运行此代码可知，float64占用了8个字节</p>
<p>  <code>var num float32 = 3.1415926</code></p>
<p>  <code>fmt.Printf(&quot;%.4f&quot;, num)</code></p>
<p>%.nf也可用类似的方法保留任意n位的小数</p>
<h3 id="Go-语言中浮点数默认是-float64"><a href="#Go-语言中浮点数默认是-float64" class="headerlink" title="Go 语言中浮点数默认是 float64"></a>Go 语言中浮点数默认是 float64</h3><p><code>num := 1.1</code></p>
<p><code>fmt.Printf(&quot;值：%v--类型:%T&quot;, num, num) //值：1.1--类型:float64</code></p>
<p>和操作系统的位数同样相关</p>
<h3 id="科学计数法表示浮点类型"><a href="#科学计数法表示浮点类型" class="headerlink" title="科学计数法表示浮点类型"></a>科学计数法表示浮点类型</h3><p>  <code>var num float32 = 3.14e2</code></p>
<p>  <code>fmt.Println(num)</code></p>
<p>表示3.14乘以10的平方，当然，e的后面同样可以接负数次方</p>
<h3 id="Golang中精度丢失的问题"><a href="#Golang中精度丢失的问题" class="headerlink" title="Golang中精度丢失的问题"></a>Golang中精度丢失的问题</h3><p>几乎所有的编程语言都有精度丢失这个问题，这是典型的二进制浮点数精度损失问题，在定<br>长条件下，二进制小数和十进制小数互转可能有精度丢失。</p>
<p>  <code>var num float64 = 1129.6</code></p>
<p>  <code>fmt.Println(num * 100)</code></p>
<p>输出结果为：112959.99999999999</p>
<p>解决方法：使用第三方包来解决精度问题</p>
<p><a target="_blank" rel="noopener" href="https://github.com/shopspring/decimal">https://github.com/shopspring/decimal</a></p>
<h3 id="int类型转换为float类型"><a href="#int类型转换为float类型" class="headerlink" title="int类型转换为float类型"></a>int类型转换为float类型</h3><p>  <code>a := 10</code></p>
<p>  <code>b := float64(a)</code></p>
<p>  <code>fmt.Printf(&quot;b的类型是%T&quot;, b)</code></p>
<p>运行这个代码，将a转化为float类型，但是转化过程中可能会产生精度的丢失</p>
<h3 id="float类型转换为int类型"><a href="#float类型转换为int类型" class="headerlink" title="float类型转换为int类型"></a>float类型转换为int类型</h3><p>  <code>var a float32 = 12.34</code></p>
<p>  <code>b := int(a)</code></p>
<p>  <code>fmt.Printf(&quot;b的类型是%T,数值是%v&quot;, b, b)</code></p>
<p>运行上面代码，得到的输出是 b的类型是int,数值是<strong>12</strong>。可以看到，转化的过程相当于一个截取的过程，只取到整数部分，因此不建议将float转化为int</p>
<h1 id="2-布尔数据"><a href="#2-布尔数据" class="headerlink" title="2. 布尔数据"></a>2. 布尔数据</h1><p>GO语言中以bool类型进行声明布尔型数据，布尔型数据只有True和false两个值</p>
<p>注意：</p>
<p>1.布尔类型变量的默认值为false</p>
<p>2.GO语言中不允许将整型强制转换为布尔型</p>
<p>3.布尔型<strong>无法</strong>参与数值运算，也<strong>无法</strong>于其他类型进行转换</p>
<p>  <code>var flag bool = true</code></p>
<p>  <code>fmt.Printf(&quot;flag的数值是%v,flag的类型是%T&quot;, flag, flag)</code></p>
<p>可以的到其输出结果为flag的数值是true,flag的类型是bool</p>
<p>也可运行如下代码：</p>
<p>  <code>var b bool</code></p>
<p>  <code>fmt.Printf(&quot;b的类型是%T&quot;, b)</code></p>
<p>得到的结果为b的类型是bool，由此可知，bool的默认值为false。与此相关，string的默认值为空，int的默认值为0，float类型数据默认值同样是0，只是位数不同。</p>
<p><strong>GO语言不允许将整型转化为布尔型，下面演示</strong>：</p>
<p>  <code>var b int = 1</code></p>
<p>  <code>if b &#123;</code></p>
<p>​    <code>fmt.Println(&quot;True&quot;)</code></p>
<p><code>&#125;</code></p>
<p>此时输出会报错 non-boolean condition in if statement</p>
<p>如果改为</p>
<p>  <code>var b = true</code></p>
<p>  <code>if b &#123;</code></p>
<p>​    <code>fmt.Println(&quot;True&quot;)</code></p>
<p>  <code>&#125;</code></p>
<p>则输出正常打印出True</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/21/Day6/" data-id="cmftphbk6000034d190dea98z" data-title="GO语言教程Day6" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%B5%AE%E7%82%B9%E5%9E%8B-%E5%B8%83%E5%B0%94%E5%9E%8B/" rel="tag">GO语言基本数据类型 浮点型 布尔型</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Day5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/21/Day5/" class="article-date">
  <time class="dt-published" datetime="2025-09-21T11:47:20.000Z" itemprop="datePublished">2025-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/21/Day5/">GO语言教程Day5</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-Golang数据类型介绍"><a href="#1-Golang数据类型介绍" class="headerlink" title="1. Golang数据类型介绍"></a>1. Golang数据类型介绍</h1><p>Golang语言分为基本数据类型和复合数据类型</p>
<p>基本数据类型有：</p>
<p>整形，浮点型，布尔型，字符串</p>
<p>复合数据类型有：</p>
<p>数组，切片，结构体，函数，map，通道，接口等</p>
<h1 id="2-整形"><a href="#2-整形" class="headerlink" title="2. 整形"></a>2. 整形</h1><p>  <code>var num int = 10</code></p>
<p>  <code>fmt.Printf(&quot;类型是%T&quot;, num)</code></p>
<p>定义了int类型，赋值不能是其他形式</p>
<p>整形分为两大类，一类是有符号整型，一类是无符号整型：</p>
<p>有符号整型按长度分为：int8，int16，int32，int64</p>
<p>对应的无符号整型为：uint8，uint16，uint32，uint64</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围（数值）</th>
<th>数学表达</th>
<th>占用空间</th>
<th align="center">是否有符号</th>
</tr>
</thead>
<tbody><tr>
<td>int8</td>
<td>-128 到 127</td>
<td>-2^7 到 2^7-1</td>
<td>1 个字节</td>
<td align="center">有</td>
</tr>
<tr>
<td>int16</td>
<td>-32,768 到 32,767</td>
<td>-2^15 到 2^15-1</td>
<td>2 个字节</td>
<td align="center">有</td>
</tr>
<tr>
<td>int32</td>
<td>-2,147,483,648 到 2,147,483,647</td>
<td>-2^31 到 2^31-1</td>
<td>4 个字节</td>
<td align="center">有</td>
</tr>
<tr>
<td>int64</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
<td>-2^63 到 2^63-1</td>
<td>8 个字节</td>
<td align="center">有</td>
</tr>
<tr>
<td>uint8</td>
<td>0 到 255</td>
<td>0 到 2^8-1</td>
<td>1 个字节</td>
<td align="center">无</td>
</tr>
<tr>
<td>uint16</td>
<td>0 到 65,535</td>
<td>0 到 2^16-1</td>
<td>2 个字节</td>
<td align="center">无</td>
</tr>
<tr>
<td>uint32</td>
<td>0 到 4,294,967,295</td>
<td>0 到 2^32-1</td>
<td>4 个字节</td>
<td align="center">无</td>
</tr>
<tr>
<td>uint64</td>
<td>0 到 18,446,744,073,709,551,615</td>
<td>0 到 2^64-1</td>
<td>8 个字节</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>找一个合适的长度，避免溢出</p>
<h4 id="关于字节："><a href="#关于字节：" class="headerlink" title="关于字节："></a>关于字节：</h4><p>字节也叫byte，是计算机数据的基本储存单位，8bit&#x3D;1Byte 1024Byte&#x3D;1KB, 在电脑里一个中文占两个字节。</p>
<h3 id="unsafe-Sizeof包"><a href="#unsafe-Sizeof包" class="headerlink" title="unsafe.Sizeof包"></a>unsafe.Sizeof包</h3><p>查看不同长度类型的包</p>
<p>  <code>var num1 int8 = 98</code></p>
<p>  <code>var num2 int64 = 98</code></p>
<p>  <code>fmt.Println(unsafe.Sizeof(num1))</code></p>
<p>  <code>fmt.Println(unsafe.Sizeof(num2))</code></p>
<p><code>unsafe.Sizeof()</code>结果是以字节计数，所以输出的结果为：1 8</p>
<h3 id="int类型转换"><a href="#int类型转换" class="headerlink" title="int类型转换"></a>int类型转换</h3><p>  <code>var num1 int8 = 1</code></p>
<p>  <code>var num2 int16 = 1</code></p>
<p>  <code>fmt.Println(num1 + num2)</code></p>
<p>同样长度的变量运算才能正常运行，因此上面的代码是运行不了的，可以对变量进行强制的转换，比如：</p>
<p>  <code>var num1 int8 = 1</code></p>
<p>  <code>var num2 int16 = 1</code></p>
<p>  <code>fmt.Println(int16(num1) + num2)</code></p>
<p>此时代码正常运行，可以得到输出： 2</p>
<p>转换类型时候，尤其是高位数据向低位数据转换时，<strong>不要超过该类型的范围</strong></p>
<p>  <code>var num1 int16 = 130</code></p>
<p>  <code>fmt.Println(int8(num1))</code></p>
<p>此时代码虽然能正常运行，但是得到的结果却是-126，很明显是130的补码</p>
<h3 id="数字字面量语法"><a href="#数字字面量语法" class="headerlink" title="数字字面量语法"></a>数字字面量语法</h3><p>  <code>num := 30</code></p>
<p>  <code>fmt.Printf(&quot;num等于%v,类型为%T\n&quot;, num, num)</code></p>
<p>  <code>fmt.Println(unsafe.Sizeof(num))</code></p>
<p>计算机默认以电脑的位数储存信息，比如我用的是64位电脑，因此使用int时，默认使用64位储存信息</p>
<p>Go1.13 版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p>
<p>  <code>num := 30</code></p>
<p>  <code>// fmt.Println(unsafe.Sizeof(num))</code></p>
<p>  <code>fmt.Printf(&quot;num等于%b\n&quot;, num)</code></p>
<p>  <code>fmt.Printf(&quot;num等于%o&quot;, num)</code></p>
<p>可以输出：</p>
<p>num等于11110<br>num等于36</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/21/Day5/" data-id="cmftpc43c0000ewd120hb25ty" data-title="GO语言教程Day5" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">语言基本数据类型</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-day4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/19/day4/" class="article-date">
  <time class="dt-published" datetime="2025-09-19T14:46:41.000Z" itemprop="datePublished">2025-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/19/day4/">GO语言教程Day4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-GO语言中的常量"><a href="#1-GO语言中的常量" class="headerlink" title="1. GO语言中的常量"></a>1. GO语言中的常量</h1><p>相对于变量，常量的值是恒定不变的值</p>
<h2 id="1-1-使用const定义常量"><a href="#1-1-使用const定义常量" class="headerlink" title="1.1 使用const定义常量"></a>1.1 使用const定义常量</h2><p>常量定义方法和变量定义方法类似。例如：</p>
<p><code>const pi=3.1415926</code></p>
<p>注意，定义好常量之后必须赋值，例如：</p>
<p>  <code>const pi float32</code></p>
<p>  <code>pi = 3.1415</code></p>
<p>  <code>fmt.Println(pi)</code></p>
<p>这时候运行会报错。</p>
<p>  <code>var pi float32</code></p>
<p>  <code>pi = 3.1415</code></p>
<p>  <code>fmt.Println(pi)</code></p>
<p>而这么定义，是可以正常运行的。</p>
<h2 id="1-2-常量特性"><a href="#1-2-常量特性" class="headerlink" title="1.2 常量特性"></a>1.2 常量特性</h2><p>常量的值是不可改变的，例如：</p>
<p>  <code>const a = &quot;1&quot;</code></p>
<p>  <code>a = &quot;2&quot;</code></p>
<p>  <code>fmt.Println(&quot;a&quot;)</code></p>
<p>此时运行会报错</p>
<h2 id="1-3-一次声明多个常量"><a href="#1-3-一次声明多个常量" class="headerlink" title="1.3 一次声明多个常量"></a>1.3 一次声明多个常量</h2><p>const(</p>
<p>​	a&#x3D;”1”</p>
<p>​	b&#x3D;”2”</p>
<p>)</p>
<p>const同时声明了多个常量时，如果忽略了后面的值，则后面声明的变量和<strong>上面一行</strong>的值相同</p>
<p><code>func main() &#123;</code></p>
<p>  <code>const (</code></p>
<p>​    <code>A = &quot;A&quot;</code></p>
<p>​    <code>B</code></p>
<p>​    <code>C = &quot;C&quot;</code></p>
<p>​    <code>D</code></p>
<p>  <code>)</code></p>
<p>  <code>fmt.Println(A, B, C, D)</code></p>
<p><code>&#125;</code></p>
<p>此时代码运行结果为A A C C</p>
<h2 id="1-4-const常量结合iota的使用"><a href="#1-4-const常量结合iota的使用" class="headerlink" title="1.4 const常量结合iota的使用"></a>1.4 const常量结合iota的使用</h2><p>iota 是 golang 语言的常量计数器,只能在常量的表达式中使用。iota 在 const 关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p>
<p>iota主要用于一次定义多个变量，如果令常量为iota，那么此常量为0.</p>
<p>  <code>const (</code></p>
<p>​    <code>a = iota</code></p>
<p>​    <code>b</code></p>
<p>​    <code>_</code>&#x2F;（跳过某些值）</p>
<p>​    <code>_</code></p>
<p>​    <code>c</code></p>
<p>  <code>)</code></p>
<p>  <code>fmt.Println(a, b, c)</code></p>
<p>运行结果为0 1 4</p>
<h3 id="iota在声明中插队"><a href="#iota在声明中插队" class="headerlink" title="iota在声明中插队"></a>iota在声明中插队</h3><p>  <code>const (</code></p>
<p>​    <code>a = iota</code></p>
<p>​    <code>b = 100</code></p>
<p>​    <code>c = iota</code></p>
<p>​    <code>d</code></p>
<p>  <code>)</code></p>
<p>  <code>fmt.Println(a, b, c, d)</code></p>
<p>运行此代码的结果为0 100 2 3。相当于b占用了1这个位置，称为在声明中插队</p>
<h3 id="多个iota可以定义在一行"><a href="#多个iota可以定义在一行" class="headerlink" title="多个iota可以定义在一行"></a>多个iota可以定义在一行</h3><p>  <code>const (</code></p>
<p>​    <code>a, b = iota + 1, iota + 2 //1 2</code></p>
<p>​    <code>c, d //2 3</code></p>
<p>​    <code>e, f//3 4</code></p>
<p>  <code>)</code></p>
<p>  <code>fmt.Println(a, b, c, d, e, f)</code></p>
<p>运行此代码，根据上面的知识，a,b的值分别为1，2，那么c,d的值就是对应位置的值再加1，所以此代码的运行结果为1 2 2 3 3 4</p>
<h1 id="2-GO语言常量变量命名规则"><a href="#2-GO语言常量变量命名规则" class="headerlink" title="2. GO语言常量变量命名规则"></a>2. GO语言常量变量命名规则</h1><p>和前面的变量命名规则类似，但是注意，GO语言区分大小写，所以age和Age是两个不同的变量或者常量。</p>
<p>建议命名遵循驼峰命名的规则，例如：</p>
<p>一个单词时，建议小写</p>
<p><code>var username=18</code></p>
<p>多个单词时组成时，单词和单词之间首字母大写</p>
<p>&#96;&#96;var maxAge&#x3D;18 &#x2F;&#x2F;小驼峰表示私有&#96;</p>
<p><code>var MaxAge=19 //大驼峰表示公有</code></p>
<h1 id="3-GO语言的代码风格"><a href="#3-GO语言的代码风格" class="headerlink" title="3. GO语言的代码风格"></a>3. GO语言的代码风格</h1><p>代码每一行结束不用写分号（加入也不算错）</p>
<p>运算符左右建议加空格</p>
<p>GO语言推荐使用驼峰命名法</p>
<p>强制的代码风格 </p>
<p><code>go fmt main.go</code> 在终端运行，可以格式化文档，让代码风格保持一致（安装了go拓展包后不需要此代码）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/19/day4/" data-id="cmfqywe5r0000iwd1bzl9d1xa" data-title="GO语言教程Day4" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%88%E4%B8%8B%EF%BC%89/" rel="tag">Go变量，常量，变量命名规则（下）</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Day3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/17/Day3/" class="article-date">
  <time class="dt-published" datetime="2025-09-17T12:22:43.000Z" itemprop="datePublished">2025-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/17/Day3/">GO语言学习记录Day3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-变量类型"><a href="#1-变量类型" class="headerlink" title="1. 变量类型"></a>1. 变量类型</h1><p>变量(Variable)的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有:整型、浮点型、布尔型等。<br>Go 语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用</p>
<h1 id="2-GO-语言中变量的声明"><a href="#2-GO-语言中变量的声明" class="headerlink" title="2. GO 语言中变量的声明"></a>2. GO 语言中变量的声明</h1><p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为<strong>数字</strong>。Go 语言中关键字和保留字都不能用作变量名。<br>Go 语言中的变量需要声明后才能使用，同一作用域内<strong>不支持重复声明</strong>。 并且 Go 语言的变量声明后必须使用。</p>
<p>需要说明的是，只是不支持重复声明，但仍可以重新赋值，如：</p>
<p>  <code>a := 1</code></p>
<p>  <code>a = 2</code></p>
<p>  <code>fmt.Println(a)</code></p>
<p>此时打印出的结果正常显示2</p>
<p>如果打印代码</p>
<p>  <code>a := 1</code></p>
<p>  <code>a := 2</code></p>
<p>  <code>fmt.Println(a)</code></p>
<p>此时便会报错</p>
<h2 id="2-1-var变量声明"><a href="#2-1-var变量声明" class="headerlink" title="2.1 var变量声明"></a>2.1 var变量声明</h2><h3 id="2-1-1-单变量赋值"><a href="#2-1-1-单变量赋值" class="headerlink" title="2.1.1 单变量赋值"></a>2.1.1 单变量赋值</h3><p>格式： var 变量名称 类型 如 <code>var uername string</code> ，类型可以省略。</p>
<p>在未进行赋值时，打印值为空</p>
<p>  <code>var username string = &quot;张三&quot;</code></p>
<p>  <code>fmt.Println(username)</code></p>
<p>赋值之后，可正常打印出张三</p>
<p>也可以这样定义</p>
<p><code>var usename string</code></p>
<p><code>username = &quot;张三&quot;</code></p>
<p>注意，此时变量类型不能省略，否则会报错</p>
<h3 id="2-1-2-多变量赋值"><a href="#2-1-2-多变量赋值" class="headerlink" title="2.1.2 多变量赋值"></a>2.1.2 多变量赋值</h3><h4 id="多变量同种类型"><a href="#多变量同种类型" class="headerlink" title="多变量同种类型"></a>多变量同种类型</h4><p>例如：</p>
<p><code>var a1,a2 string</code></p>
<p><code>a1=&quot;aaa&quot;</code></p>
<p><code>a2=&quot;aaaaa&quot;</code></p>
<p><code>fmt.Println(a1,a2)</code></p>
<p>输出可以正常打印出 aaa aaaaa,注意，因为声明了a1 a2均为字符串，不可以对a1 a2赋值其他类型的数据</p>
<h4 id="多变量不同类型"><a href="#多变量不同类型" class="headerlink" title="多变量不同类型"></a>多变量不同类型</h4><p>例如：</p>
<p>  <code>var (</code></p>
<p>​    <code>name string</code></p>
<p>​    <code>age  int</code></p>
<p>​    <code>sex  string</code></p>
<p>  <code>)</code></p>
<p>  <code>name = &quot;张三&quot;</code></p>
<p>  <code>age = 20</code></p>
<p>  <code>sex = &quot;男&quot;</code></p>
<p>  <code>fmt.Println(name, age, sex)</code></p>
<p>可以正常打印出张三 20 男</p>
<h3 id="2-2-短变量声明法"><a href="#2-2-短变量声明法" class="headerlink" title="2.2 短变量声明法"></a>2.2 短变量声明法</h3><p>格式：变量名：&#x3D;表达式 例如 <code>username := &quot;张三&quot;</code></p>
<p>短变量只能用于局部变量声明，不能用于全局变量声明，即在func main里面的短变量可以正常引用，但不能引用func main外的全局变量，需要声明全局变量可以用上面的var方法</p>
<p>短变量声明法声明多个变量，例如</p>
<p>  <code>a, b, c := 1, 2, 3</code></p>
<p>  <code>a, b, c := 1, 2, &quot;三&quot;</code></p>
<p>上面两种声明方法都是正确的，说明短变量声明法声明多个变量可以声明不同类型的，十分方便</p>
<h1 id="3-匿名变量声明"><a href="#3-匿名变量声明" class="headerlink" title="3. 匿名变量声明"></a>3. 匿名变量声明</h1><h2 id="3-1-什么是匿名变量"><a href="#3-1-什么是匿名变量" class="headerlink" title="3.1 什么是匿名变量"></a>3.1 什么是匿名变量</h2><p>在 <strong>Go 语言</strong> 里，匿名变量（也叫 <strong>空白标识符</strong>，<code>_</code>）就是一个特殊的标识符，用来 <strong>占位但不使用</strong></p>
<h2 id="3-2-匿名变量演示"><a href="#3-2-匿名变量演示" class="headerlink" title="3.2 匿名变量演示"></a>3.2 匿名变量演示</h2><h3 id="3-2-1-func函数语法示例"><a href="#3-2-1-func函数语法示例" class="headerlink" title="3.2.1 func函数语法示例"></a>3.2.1 func函数语法示例</h3><p><code>func 函数名(参数列表) (返回值列表) &#123;</code><br>    <code>// 函数体</code><br>    <code>return 返回值</code><br><code>&#125;</code></p>
<p>函数名按照命名规则即可，该函数需要两个括号，前面一个括号表示输入，后面一个括号表示输出</p>
<p>例如：</p>
<p><code>package main</code></p>
<p><code>import &quot;fmt&quot;</code></p>
<p><code>// 定义函数：输入参数 (长和宽)，输出参数 (面积和周长)</code><br><code>func calcRectangle(length float64, width float64) (float64, float64) &#123;</code><br>	<code>area := length * width            // 面积</code><br>	<code>perimeter := 2 * (length + width) // 周长</code><br>	<code>return area, perimeter</code><br><code>&#125;</code></p>
<p><code>func main() &#123;</code><br>	<code>// 调用函数时传入参数</code><br>	<code>a, p := calcRectangle(5, 3)</code></p>
<pre><code>fmt.Println(&quot;面积:&quot;, a)
fmt.Println(&quot;周长:&quot;, p)
</code></pre>
<p>}</p>
<p>注意：第一个括号里填的是输入的数据，比如目标是计算面积和周长，你需要输入长和宽，后面必须注明数据类型，输出的括号同样如此。</p>
<p>在引用时，go给了几种选择：</p>
<h4 id="1-全部接收（标准用法）"><a href="#1-全部接收（标准用法）" class="headerlink" title="1. 全部接收（标准用法）"></a>1. <strong>全部接收（标准用法）</strong></h4><p>函数返回两个值时，你可以用两个变量来接收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name, age := getUserinfo()</span><br><span class="line">fmt.Println(&quot;姓名:&quot;, name, &quot;年龄:&quot;, age)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-只接收其中一部分（用匿名变量-丢弃）"><a href="#2-只接收其中一部分（用匿名变量-丢弃）" class="headerlink" title="2. 只接收其中一部分（用匿名变量 _ 丢弃）"></a>2. <strong>只接收其中一部分（用匿名变量 <code>_</code> 丢弃）</strong></h4><p>如果你只关心一个结果，可以把另一个丢给 <code>_</code>：</p>
<p>匿名变量不存在重复声明的问题，也即前面有匿名变量，后面依旧可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name, _ := getUserinfo()  // 只要姓名</span><br><span class="line">fmt.Println(&quot;姓名:&quot;, name)</span><br><span class="line"></span><br><span class="line">_, age := getUserinfo()   // 只要年龄</span><br><span class="line">fmt.Println(&quot;年龄:&quot;, age)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-不接收（直接调用但忽略结果）"><a href="#3-不接收（直接调用但忽略结果）" class="headerlink" title="3. 不接收（直接调用但忽略结果）"></a>3. <strong>不接收（直接调用但忽略结果）</strong></h4><p>函数返回值可以完全不接收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getUserinfo()  // 返回值被丢弃，不赋值给任何变量</span><br></pre></td></tr></table></figure>

<p>这种情况很少见，但合法。</p>
<hr>
<h4 id="4-立即使用（不命名变量，直接嵌套在表达式中）"><a href="#4-立即使用（不命名变量，直接嵌套在表达式中）" class="headerlink" title="4. 立即使用（不命名变量，直接嵌套在表达式中）"></a>4. <strong>立即使用（不命名变量，直接嵌套在表达式中）</strong></h4><p>你也可以直接把函数调用放在需要的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(getUserinfo())  </span><br><span class="line">// 输出: zhangsan 10</span><br></pre></td></tr></table></figure>

<p>注意：这种情况下，<code>fmt.Println</code> 会自动打印两个返回值，中间加空格。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/17/Day3/" data-id="cmfo1c4d6000078d14r1u4ara" data-title="GO语言学习记录Day3" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="tag">Go变量，常量，变量命名规则（上）</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Day1/" rel="tag">Day1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GOlang%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/" rel="tag">GOlang中基本数据类型之间的转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%B5%AE%E7%82%B9%E5%9E%8B-%E5%B8%83%E5%B0%94%E5%9E%8B/" rel="tag">GO语言基本数据类型 浮点型 布尔型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="tag">Go变量，常量，变量命名规则（上）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%88%E4%B8%8B%EF%BC%89/" rel="tag">Go变量，常量，变量命名规则（下）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/" rel="tag">byte类型和rune类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/" rel="tag">go语言的运算符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" rel="tag">字符串 字符串里面的方法详解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%EF%BC%8Cfmt%E5%8C%85%EF%BC%8Cprintln%E7%AD%89/" rel="tag">定义变量，fmt包，println等.</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">语言基本数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%83%E4%B9%A0%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/" rel="tag">运算符练习，位运算符</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Day1/" style="font-size: 10px;">Day1</a> <a href="/tags/GOlang%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">GOlang中基本数据类型之间的转换</a> <a href="/tags/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%B5%AE%E7%82%B9%E5%9E%8B-%E5%B8%83%E5%B0%94%E5%9E%8B/" style="font-size: 10px;">GO语言基本数据类型 浮点型 布尔型</a> <a href="/tags/Go%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%88%E4%B8%8A%EF%BC%89/" style="font-size: 10px;">Go变量，常量，变量命名规则（上）</a> <a href="/tags/Go%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%EF%BC%88%E4%B8%8B%EF%BC%89/" style="font-size: 10px;">Go变量，常量，变量命名规则（下）</a> <a href="/tags/byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">byte类型和rune类型</a> <a href="/tags/go%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/" style="font-size: 10px;">go语言的运算符</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" style="font-size: 10px;">字符串 字符串里面的方法详解</a> <a href="/tags/%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%EF%BC%8Cfmt%E5%8C%85%EF%BC%8Cprintln%E7%AD%89/" style="font-size: 10px;">定义变量，fmt包，println等.</a> <a href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">语言基本数据类型</a> <a href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%83%E4%B9%A0%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/" style="font-size: 10px;">运算符练习，位运算符</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">十月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">九月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/05/Day12/">Day12</a>
          </li>
        
          <li>
            <a href="/2025/10/05/Day11/">GO语言教程Day11</a>
          </li>
        
          <li>
            <a href="/2025/10/05/Day10/">GO语言教程Day10</a>
          </li>
        
          <li>
            <a href="/2025/09/24/Day9/">GO语言教程Day9</a>
          </li>
        
          <li>
            <a href="/2025/09/23/Day8/">GO语言教程Day8</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 reason<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>